{"version":3,"sources":["project/metaballs/text/index.ts"],"names":["Object","defineProperty","__webpack_exports__","value","htmlText","javaScriptText"],"mappings":"qDAAAA,OAAAC,eAAAC,EAAA,cAAAC,OAAA,IAqFeD,EAAA,SAAEE,SArFA,4WAqFUC,eAvEJ","file":"static/js/31.f9b632d7.chunk.js","sourcesContent":["const htmlText = `<svg\r\n    className={style.svgContainer}\r\n    viewBox=\"0 0 1200 240\"\r\n    preserveAspectRatio=\"xMidYMid slice\"\r\n>\r\n    <g strokeWidth=\"6\" fill=\"#fff\" stroke=\"#333\">\r\n    <circle id=\"js-circle1\" cx=\"400\" cy=\"100\" r=\"96\" />\r\n    <circle id=\"js-circle2\" cx=\"400\" cy=\"100\" r=\"64\" stroke=\"none\" />\r\n    <path id=\"js-connector\" d=\"\" fill=\"#333\" />\r\n    </g>\r\n</svg>\r\n`;\r\n\r\n\r\nconst javaScriptText = `//启动部分：\r\n    const circle1 = document.querySelector(\"#js-circle1\");\r\n    const circle2 = document.querySelector(\"#js-circle2\");\r\n    const connector = document.querySelector(\"#js-connector\");\r\n    const VIEWBOX_SIZE = { W: 1200, H: 400 };\r\n    const SIZES = {\r\n      CIRCLE1: 96,\r\n      CIRCLE2: 64\r\n    };\r\n\r\n    // of：创建一个 Observable，它会依次发出由你提供的参数，最后发出完成通知。\r\n    // do：拦截源 Observable 上的每次发送并且运行一个函数，但返回的输出 Observable 与 源 Observable 是相同的。\r\n    const circle1$ = Rx.Observable.of([600, 120]).do(loc => {\r\n      moveTo(loc, circle1);\r\n    });\r\n\r\n    // interval：创建一个 Observable ，该 Observable 使用指定的 IScheduler ，并以指定时间间隔发出连续的数字。\r\n    // map ：转化发出的value\r\n    // Rx.Scheduler.animationFrame : 动画帧调度器\r\n    const circle2$ = Rx.Observable.interval(0, Rx.Scheduler.animationFrame)\r\n      .map(frame => 200 * Math.sin(frame / 500)) //利用余弦函数得到变化的x值\r\n      .map(x => [600 + x, 120])\r\n      .do(loc => {\r\n        moveTo(loc, circle2);\r\n      });\r\n\r\n    // combineLatest：组合多个 Observables 来创建一个 Observable ，该 Observable 的值根据每个输入 Observable 的最新值计算得出的。\r\n    Rx.Observable.combineLatest(circle1$, circle2$, (circle1Loc, circle2Loc) =>\r\n      metaball(SIZES.CIRCLE1, SIZES.CIRCLE2, circle1Loc, circle2Loc)\r\n    ).subscribe(path => {\r\n      connector.setAttribute(\"d\", path);\r\n    });\r\n\r\n//核心部分：\r\n    // @angleBetweenCenters : 两圆心夹角极坐标\r\n    // @spread : 两圆切点与大圆圆心成角\r\n    // @u1,u2: 两圆交点到圆心连线与两圆心连线的夹角\r\n    // v：粘度系数，0-1，越大越趋于直线\r\n  \r\n    // 1.利用两圆切线求出四个切点的极坐标\r\n    const angle1 = angleBetweenCenters + u1 + (spread - u1) * v;\r\n    const angle2 = angleBetweenCenters - u1 - (spread - u1) * v;\r\n    const angle3 =\r\n      angleBetweenCenters + Math.PI - u2 - (Math.PI - u2 - spread) * v;\r\n    const angle4 =\r\n      angleBetweenCenters - Math.PI + u2 + (Math.PI - u2 - spread) * v;\r\n    // 2.转换极坐标为笛卡尔坐标系\r\n    const p1 = getVector(center1, angle1, radius1);\r\n    const p2 = getVector(center1, angle2, radius1);\r\n    const p3 = getVector(center2, angle3, radius2);\r\n    const p4 = getVector(center2, angle4, radius2);\r\n    // 3.利用四个切点再对自身圆坐切线，求得四个手柄的点\r\n    const totalRadius = radius1 + radius2;\r\n    const d2Base = Math.min(v * handleLenRate, dist(p1, p3) / totalRadius);\r\n  \r\n    const d2 = d2Base * Math.min(1, d * 2 / (radius1 + radius2));\r\n  \r\n    const r1 = radius1 * d2;  //手柄长度\r\n    const r2 = radius2 * d2;  //手柄长度\r\n  \r\n    const h1 = getVector(p1, angle1 - HALF_PI, r1);\r\n    const h2 = getVector(p2, angle2 + HALF_PI, r1);\r\n    const h3 = getVector(p3, angle3 + HALF_PI, r2);\r\n    const h4 = getVector(p4, angle4 - HALF_PI, r2);\r\n  \r\n    // 4.根据切点坐标、手柄坐标、圆半径绘制出path的路线系数\r\n    const path = metaballToPath(p1,p2,p3,p4,h1,h2,h3,h4,d > radius1, radius2);\r\n\r\n    return path;\r\n`;\r\n\r\nexport default { htmlText, javaScriptText };\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/project/metaballs/text/index.ts"],"sourceRoot":""}