{"version":3,"sources":["project/serviceGenerator/text/index.ts"],"names":["Object","defineProperty","__webpack_exports__","value","javaScriptText","readMeText","exampleText","title","text"],"mappings":"qDAAAA,OAAAC,eAAAC,EAAA,cAAAC,OAAA,IAwQeD,EAAA,SAAEE,eA/MM,6pQA+MUC,WAvQ/B,keAuQ2CC,cA/PzCC,MAAO,2BAAQC,KAAM,4kBAOrBD,MAAO,2BAAQC,KAAM,gfAoBrBD,MAAO,2BAAQC,KAAM","file":"static/js/23.d9556334.chunk.js","sourcesContent":["const readMeText =\r\n  `  1、根据接口对象自动封装出对应的服务层<br/>\r\n    2、加入和缓存、截流的可选功能<br/>\r\n    3、自动处理请求前的加载中动画与请求出错的提示动画<br/>\r\n    4、可以通过传入模拟数据脱离后端开发\r\n`;\r\n\r\nconst exampleText = [\r\n  {\r\n    title: '参数说明', text: `\r\n@type          : 请求类型 ('post' | String )\r\n@isCache       : 是否开启缓存功能 (true | Boolen )\r\n@throttleTime  : 截流间隔 (0 | Number )（单位ms,传0表示关闭）\r\n@axiosConfig   : axios配置选项 ({} | Object) (#支持axios文档中的所有对请求的配置选项)\r\n@debugData     : 调试数据，有传此项会直接返回此项作为接口数据\r\n  `}, {\r\n    title: '接口声明', text: `\r\nimport serviceGenerator from \"@/utils/serviceGenerator\";\r\n\r\n#1.基础模式\r\nexport default serviceGenerator(\r\n  {\r\n    fetchFansList: \"/r/Mall_AllDis/getAllDisCenterData/\",\r\n    fetchOrderList: \"/r/Mall_AllDis/myOneFansDetail\"\r\n  }\r\n);\r\n\r\n#2.传参数模式\r\nexport default serviceGenerator(\r\n  {\r\n    fetchFansList: { url:\"/r/Mall_AllDis/getAllDisCenterData/\", config:{}},\r\n    fetchOrderList:  { url:\"/r/Mall_AllDis/myOneFansDetail\", config:{}}\r\n  }\r\n);\r\n    `\r\n  }, {\r\n    title: '业务调用', text: `\r\nimport API from './service'\r\n\r\nAPI.fetchOrderList(\r\n        // 接口要传的参数主体\r\n        params,\r\n        // 服务层的配置选项（不传即采用默认）\r\n        // config覆盖关系 调用处config > 声明处config > 默认config\r\n        { type: \"post\", isCache: false }     \r\n      ).then(res => {   \r\n        console.log(res)\r\n      }.catch(err => {\r\n        consoel.log(err.msg)\r\n      })\r\n)\r\n\r\n//不用再处理beforeSend、complete、catch部分，会自动添加`\r\n  }\r\n]\r\n  ;\r\n\r\nconst javaScriptText = `\r\nimport qs from \"qs\";\r\nimport { Loading, MessageBox } from 'element-ui';\r\n// import { Toast, Dialog } from \"vant\";\r\nimport axios from \"axios\";\r\n\r\n// import ProxyPolyfill from \"./proxyPolyfill\"\r\n\r\nlet _cache = {};\r\nlet generatorAxios = axios.create();\r\nlet _loadingInstance = null;\r\n\r\nconst globalConfig = {\r\n    commonParams: {},\r\n};\r\n\r\nconst defaultConfig = {\r\n    type: \"post\",\r\n    isCache: false,\r\n    isThrottle: false,\r\n    throttleTime: 0,\r\n    axiosConfig: {}\r\n    // debugData  不传即没有启用调试数据\r\n};\r\n\r\n// 添加请求拦截器\r\ngeneratorAxios.interceptors.request.use(\r\n    function (config) {\r\n        _loadingInstance = Loading.service({\r\n            fullscreen: true,\r\n            lock: true,\r\n            text: \"加载中\",\r\n        })\r\n        // Toast.loading({ mask: false, duration: 0, forbidClick: true, message: \"加载中\" });\r\n        return config;\r\n    },\r\n    function (error) {\r\n        MessageBox.alert('请求出错', '错误')\r\n        // Toast.fail(\"请求出错\");\r\n        return Promise.reject({ msg: \"请求出错\" });\r\n    }\r\n);\r\n\r\n// 添加响应拦截器\r\ngeneratorAxios.interceptors.response.use(\r\n    function (response) {\r\n        if (_loadingInstance) {\r\n            _loadingInstance.close();\r\n            _loadingInstance = null\r\n        }\r\n        // Toast.clear();\r\n        if (response.data.code == 200) {\r\n            let url = response.config.url,\r\n                params = response.config.data || \"0\",\r\n                res = response.request.responseText;\r\n            _cache[url] ? null : (_cache[url] = []);\r\n            let existCacheIndex;\r\n            let _cacheFliter = _cache[url].filter((item, index) => {\r\n                item.params == params ? (existCacheIndex = index) : null;\r\n                return item.params == params;\r\n            });\r\n\r\n            _cacheFliter.length > 0\r\n                ? (_cache[url][existCacheIndex] = { params, res })\r\n                : _cache[url].push({ params, res });\r\n            return response.data;\r\n        } else {\r\n            MessageBox.alert(response.data.msg || '服务器错误', '错误')\r\n            // Toast.fail(response.data.msg || '服务器错误');\r\n            // Dialog.alert({\r\n            //     title: '错误',\r\n            //     message: response.data.msg || '服务器错误'\r\n            // })\r\n            return Promise.reject(response.data || { msg: \"服务器错误\" });\r\n        }\r\n    },\r\n    function (error) {\r\n        if (_loadingInstance) {\r\n            _loadingInstance.close();\r\n            _loadingInstance = null\r\n        }\r\n        // Toast.clear();\r\n        // Toast.fail(\"响应出错\");\r\n        MessageBox.alert('响应出错', '错误')\r\n        return Promise.reject({ msg: \"响应出错\" });\r\n    }\r\n);\r\n\r\n//截流处理\r\n// const throttleProxy = fn => {\r\n//   let lastRequest = 0;\r\n//   return new Proxy(fn, {\r\n//   // return new ProxyPolyfill(fn, {\r\n//     apply(target, context, args) {\r\n//       let _config = Object.assign(defaultConfig, args[1] || {});\r\n//       let rate = _config.throttleTime !== 0 ? _config.throttleTime : 0;\r\n//       if (Date.now() - lastRequest >= rate) {\r\n//         lastRequest = Date.now();\r\n//         return fn(...args);\r\n//       } else {\r\n//         console.warn(\"本次请求被截流\");\r\n//         return Promise.reject({ msg: \"本次请求被截流\" });\r\n//       }\r\n//     }\r\n//   });\r\n// };\r\n\r\n//生成部分\r\nlet serviceGenerator = (map = {}, globalConfig = {}) => {\r\n    let ApiMap = {};\r\n    Object.entries(map).forEach(item => {\r\n        let key_map = item[0],\r\n            url_map = '', config_map = {};\r\n\r\n        // 如果直接传url地址\r\n        if (typeof item[1] == 'string') {\r\n            url_map = item[1]\r\n        } else {\r\n            // 如果传的是带参数\r\n            url_map = item[1].url;\r\n            config_map = item[1].config;\r\n        }\r\n\r\n        let outPutApi = (params = {}, config = {}) => {\r\n\r\n            //合并默认参数\r\n            let _config = Object.assign({}, defaultConfig, config_map, config);     //应该合并到一个空对象而不能是defaultConfig，否则接口config会互相影响\r\n            let _params = Object.assign({}, params, globalConfig.commonParams)\r\n            //_axiosConfig参数合并\r\n            let _axiosConfig = Object.assign(\r\n                {\r\n                    method: \"post\",\r\n                    url: url_map,\r\n                    data: qs.stringify(_params)\r\n                },\r\n                _config.axiosConfig || {},\r\n                { method: _config.type.toLowerCase() || \"post\" }\r\n            );\r\n            [\"put\", \"post\", \"patch\"].every(value => _axiosConfig.method !== value)\r\n                ? (_axiosConfig.params = _params)\r\n                : \"\";\r\n            let _request = () => generatorAxios(_axiosConfig);\r\n\r\n            //处理缓存功能\r\n            if (_config.isCache === true) {\r\n                if (_cache[url_map]) {\r\n                    let _cacheFliter = _cache[url_map].filter(\r\n                        item => item.params == qs.stringify(params)   //缓存层的params没有加入commonParams因为token是随机如果加入则无法缓存\r\n                    );\r\n                    if (_cacheFliter.length > 0) {\r\n                        _request = () => {\r\n                            console.warn(\\`您本次请求接口：\\${url_map} 的数据来自缓存。\\`);\r\n                            return Promise.resolve(JSON.parse(_cacheFliter[0].res));\r\n                        };\r\n                    }\r\n                }\r\n            }\r\n\r\n            // 调试模式\r\n            if (_config.debugData) {\r\n                _request = () => {\r\n                    console.warn(\\`您本次请求接口：\\${url_map} 的数据来自调试模式。\\`);\r\n                    return new Promise((resolve, reject) => {\r\n                        _loadingInstance = Loading.service({\r\n                            fullscreen: true,\r\n                            lock: true,\r\n                            text: \"加载中\",\r\n                        })\r\n                        // Toast.loading({ mask: false, duration: 0, forbidClick: true, message: \"加载中\" });\r\n                        setTimeout(() => {\r\n                            // Toast.clear();\r\n                            if (_loadingInstance) {\r\n                                _loadingInstance.close();\r\n                                _loadingInstance = null\r\n                            }\r\n                            const res = _config.debugData;\r\n                            if (res.code == 200) {\r\n                                resolve(res);\r\n                            } else {\r\n                                MessageBox.alert(res.msg || '服务器错误', '错误')\r\n                                // Toast.fail(res.msg || '服务器错误');\r\n                                // Dialog.alert({\r\n                                //     title: '错误',\r\n                                //     message: res.msg || '服务器错误'\r\n                                // })\r\n                                reject(res || { msg: \"服务器错误\" });\r\n                            }\r\n\r\n                        }, 1000);\r\n                    });\r\n                };\r\n            }\r\n\r\n            return _request();\r\n        };\r\n\r\n        ApiMap[key_map] = outPutApi;\r\n        //截流代理\r\n        // ApiMap[key_map] = throttleProxy(outPutApi);    //苹果6 SE 不支持proxy\r\n    });\r\n    return ApiMap;\r\n};\r\n\r\nexport default serviceGenerator;\r\n\r\n`;\r\n\r\nexport default { javaScriptText, readMeText, exampleText };\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/project/serviceGenerator/text/index.ts"],"sourceRoot":""}