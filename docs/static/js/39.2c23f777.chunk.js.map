{"version":3,"sources":["project/jquery-2/text/index.ts"],"names":["Object","defineProperty","__webpack_exports__","value","exampleText","title","text","javaScriptText"],"mappings":"qDAAAA,OAAAC,eAAAC,EAAA,cAAAC,OAAA,IA2LeD,EAAA,SAAEE,cAzLTC,MAAO,yCACPC,KAAM,2DAGND,MAAO,uEACPC,KAAM,gDAGND,MAAO,2LACPC,KAAM,iCAgLgBC,iBA3K1BF,MAAO,mBACPC,KAAM,slCAoCND,MAAO,wCACPC,KAAM,+qCA2CND,MAAO,iCACPC,KAAM","file":"static/js/39.2c23f777.chunk.js","sourcesContent":["const exampleText = [\r\n    {\r\n        title: '1.任意对象扩展',\r\n        text: `var obj = $.extend({}, { name: 'bendjen', age: '25' })`\r\n    },\r\n    {\r\n        title: '2.jQuery本身扩展  this指向jQuery本身',\r\n        text: `$.extend({ work: function () { return 1 }})`\r\n    },\r\n    {\r\n        title: '3.jQuery的实例对象扩展  this指向jQuery实例的原型对象 （.fn相当于对.prototype的简写）',\r\n        text: `$.fn.extend({sex: '男'})`\r\n    },\r\n]\r\n\r\nconst javaScriptText = [{\r\n    title: '一、this',\r\n    text: `\r\n// this:指向函数运行时所在的环境\r\n// 作用场景:1作为函数调用 2.对象方法中调用 3.构造函数中使用 4.call apply\r\n\r\n// 为什么会有this\r\n// JS是一门面向对象的函数,一切都是在对象上\r\n\r\n// 全局对象:抽象的说法(顶层函数+顶层属性+window)\r\n// 包括顶层函数(如String) 顶层属性(NaN undefined) \r\n// window::JS有一个全局作用域 window.fn window.alert,没有指明时默认从window中查找\r\n\r\n// 例子1\r\n\r\nvar obj = {\r\n    name: \"max\",\r\n    add: function () {\r\n        console.log(this)  // obj\r\n    }\r\n}\r\n\r\n// 例子2\r\n\r\nfunction Person() {\r\n    this.name = 'max' // new Person() 实例\r\n}\r\n\r\nnew Person.name;\r\n\r\n// 例子3\r\n\r\nfunction fn() {\r\n    console.log(this) // window\r\n}\r\n\r\n`\r\n}, {\r\n    title: '二、call、apply与bind',\r\n    text: `\r\n// apply call bind 都是作为函数对象的一个方法,所\r\n// 以都是Function构造函数的实例对象\r\n//  Function.propotype.call \r\n//  Function.propotype.apply\r\n//  Function.propotype.bind\r\n\r\n// 案例 1\r\n// call流程解读\r\n// 实例slice实现\r\nArray.prototype.slice = function (start, end) {\r\n    var result = new Array;\r\n    start = start || 0;\r\n    end = end || this.length\r\n    for (var i = start; i < end; i++) {\r\n        result.push(this[i])\r\n    }\r\n    return result\r\n}\r\n\r\n[1, 2, 3].slice();  // this => [1,2,3]的数组对象\r\n\r\nfunction fn(a, b, c, d) {\r\n    return [].slice.call(arguments)  // this => arguments\r\n}\r\n\r\n// 案例 2\r\n// call与apply,bind区别\r\nvar obj = {}\r\nfunction fn(a, b, c, d) {\r\n    console.log(a);\r\n    console.log(b);\r\n    console.log(c);\r\n    console.log(d);\r\n}\r\nfn.call(obj, 1, 2, 3, 4)        // 1 2 3 4\r\nfn.apply(obj, [1, 2, 3, 4])     // 1 2 3 4\r\n\r\nvar bindFn = fn.bind(obj, 1, 2) //生成的是fn的副本而不是直接调用\r\nbindFn(3, 4)    // 1 2 3 4\r\n\r\n`\r\n}, {\r\n    title: '三、Extend源码',\r\n    text: `\r\n(function (root) {\r\n    var jQuery = function () {\r\n        // 错误实例化：会造成无限自我调用，形成死循环\r\n        // return  new jQuery();  \r\n        return new jQuery.prototype.init()\r\n    }\r\n    // 为jQuery.prototype起别名jQuery.fn\r\n    jQuery.fn = jQuery.prototype = {\r\n        init: function () {\r\n            ...\r\n        },\r\n        css: function () {\r\n            ...\r\n        }\r\n    }\r\n\r\n    jQuery.fn.extend = jQuery.extend = function () {\r\n        var target = arguments[0] || {};  // 确保第一个参数有值\r\n        var length = arguments.length;\r\n        var i = 1;  // i 设置为 1 而不是 0 是因为第一个参数不用被遍历，直接被后面的参数扩展\r\n        var deep = false;\r\n        var option, name, copy, src, copyIsArray, clone;\r\n\r\n        if (typeof target === 'boolean') {\r\n            deep = target;           // 如果第一个传入为布尔值，传入是否深拷贝的变量\r\n            target = arguments[1];   // 被扩展对象从第一个变成第二个\r\n            i = 2;\r\n        }\r\n\r\n        if (typeof target !== 'object') {\r\n            target = {};    // 确保被扩展的一定是object\r\n        }\r\n\r\n\r\n        if (length === i) {\r\n            target = this;\r\n            i--;    // 被修改的target是jQuery或jQuery.fn自身，传入的第一个参数是用来给自身扩展的，所以从第一个算起\r\n            // 当以$.extend()的方式调用时 $ => this => target ;当以 $.fn.extend()的方式调用 $.fn => this => target\r\n        }\r\n\r\n        // 拷贝\r\n        for (; i < length; i++) {\r\n            // 确保参数不是null和undefind\r\n            if ((option = arguments[i]) != null) {\r\n                for (name in option) {\r\n                    copy = option[name];    // 要扩展的属性\r\n                    src = target[name];     // 被扩展的属性所在的位置\r\n\r\n                    // var obj1 = {list:[1,2,3,4]}\r\n                    // var obj2 = {list:[5,6,7,8]}\r\n                    // $.extend(true,{},obj1,obj2)\r\n\r\n                    // 深拷贝且是copy值是对象或数组\r\n                    if (deep && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {\r\n                        if (copyIsArray) {\r\n                            copyIsArray = false;    // 用于下一个参数的默认值（比如第三个参数也要默认不是数组开始）\r\n                            clone = src && jQuery.isArray(src) ? src : []; // 如果被拷贝的位置原来就已经是数组则用原来的值，否则初始化[]\r\n                        } else {\r\n                            clone = src && jQuery.isPlainObject(src) ? src : {}; // 如果被拷贝的位置原来就已经是对象则用原来的值，否则初始化{}\r\n                        }\r\n                        target[name] = jQuery.extend(deep, clone, copy)     // 核心算法：自我遍历进行下一个参数的深拷贝\r\n                    } else {    // 浅拷贝\r\n                        // 不拷贝undefined\r\n                        if (copy != undefined) {\r\n                            target[name] = copy\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return target\r\n\r\n    }\r\n\r\n    // *共享原型对象\r\n    // jQuery.prototype中的init方法和jQuery共享了原型对象\r\n    // 所以上面对jQuery原型对象添加的方法(css)也会在jquery的init的原型对象中出现\r\n\r\n    // jQuery.prototype.init.prototype = jQuery.prototype\r\n    jQuery.fn.init.prototype = jQuery.fn //上面的简写\r\n\r\n    root.$ = root.jQuery = jQuery\r\n\r\n})(this);\r\n    `\r\n}];\r\n\r\nexport default { exampleText, javaScriptText };\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/project/jquery-2/text/index.ts"],"sourceRoot":""}