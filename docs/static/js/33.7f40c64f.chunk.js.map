{"version":3,"sources":["project/jquery-5/text/index.ts"],"names":["Object","defineProperty","__webpack_exports__","value","exampleText","javaScriptText","title","text"],"mappings":"qDAAAA,OAAAC,eAAAC,EAAA,cAAAC,OAAA,IA8HeD,EAAA,SAAEE,YA9HG,+mEA8HUC,iBA9F1BC,MAAO,uBACPC,KAAM","file":"static/js/33.7f40c64f.chunk.js","sourcesContent":["const exampleText = `\r\nvar wait = function () {\r\n    var der = $.Deferred();    \r\n    // 1.创建memory队列\r\n    // 2.promise对象的done、fail、progress映射为队列的add方法\r\n    // 3.为队列的第一项add一个变更state的方法(memory的add要在fire触发后才会立即触发add的函数)\r\n    // 4.为deferred的resolve、reject、notify方法映射为 触发 队列的fireWith(context,arguments)\r\n    // 5.将deferred对象promise化,使得通过when方法可以得到deferred对象的promise\r\n    var test = function () {\r\n        console.log(\"done\");\r\n        der.resolve(\"AAA\");     //成功     队列中的处理函数  调用成功这个队列中的处理函数\r\n    }\r\n    setTimeout(test, 2000);\r\n    return der;    //延迟对象 \r\n}\r\n\r\n//延迟对象的状态 决定调用那个队列中的处理函数\r\n// 1.when方法返回deferred对象的promise\r\n// 2.promise对象的done、fail对应callbacks的list的add方法，并返回promise形成链式\r\n// 3.所以这里会边传入func会derferred对象resolved的时候边触发fire,从而开始调用这里刚才add的队列\r\n// done/fail方法对应的都是add方法，而add方法内部是返回this的,this对应的就是这里的promise对象，所以可以链式调用\r\n$.when(wait())     //promise对象promise.done()   self.add\r\n    .done(function (name) {\r\n        console.log(name)\r\n        console.log(\"执行成功\");\r\n    }).fail(function () {\r\n        console.log(\"执行失败\");\r\n    });\r\n\r\n`\r\n\r\nconst javaScriptText = [{\r\n    title: 'Deferred源码',\r\n    text: `\r\n(function (root) {\r\n    var jQuery = function (selector, context) {\r\n        // 错误实例化：会造成无限自我调用，形成死循环\r\n        // return  new jQuery();  \r\n        return new jQuery.prototype.init(selector, context)\r\n    }\r\n\r\n    // 为jQuery.prototype起别名jQuery.fn\r\n    jQuery.fn = jQuery.prototype = {\r\n        init: function (selector, context) {\r\n           ...\r\n        },\r\n\r\n    }\r\n\r\n    jQuery.fn.extend = jQuery.extend = function () { ... }\r\n\r\n    jQuery.extend({\r\n        ...\r\n        callbacks:function(options){\r\n            ...\r\n        },\r\n        // 异步回调解决方案\r\n\t\tDeferred: function(func) {\r\n            //  [ 0 : deferred的方法, 1 : promise的方法, 2 : 队列 , 3 : 最终状态]\r\n\t\t\tvar tuples = [\r\n\t\t\t\t\t[\"resolve\", \"done\", jQuery.callbacks(\"once memory\"), \"resolved\"],\r\n\t\t\t\t\t[\"reject\", \"fail\", jQuery.callbacks(\"once memory\"), \"rejected\"],\r\n\t\t\t\t\t[\"notify\", \"progress\", jQuery.callbacks(\"memory\")]\r\n\t\t\t\t],\r\n\t\t\t\tstate = \"pending\",\r\n\t\t\t\tpromise = {\r\n\t\t\t\t\tstate: function() {\r\n\t\t\t\t\t\treturn state;\r\n\t\t\t\t\t},\r\n\t\t\t\t\tthen: function( /* fnDone, fnFail, fnProgress */ ) {\r\n                    },\r\n                    // 使一个对象变成\r\n\t\t\t\t\tpromise: function(obj) {        // 这个obj可以给promise对象扩充方法和属性,如果没有直接返回内部定义的promise\r\n\t\t\t\t\t\treturn obj != null ? jQuery.extend(obj, promise) : promise;\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\tdeferred = {};\r\n\r\n\t\t\ttuples.forEach(function(tuple, i) {\r\n\t\t\t\tvar list = tuple[2],\r\n\t\t\t\t\tstateString = tuple[3];\r\n\r\n                // 为promise的done\\fail\\progree附加回调处理器 list.add\r\n\t\t\t\t// promise[ done | fail | progress ] = list.add\r\n\t\t\t\tpromise[tuple[1]] = list.add;\r\n\r\n                // Handle state\r\n                // 队列fire之后的state，\r\n                // 有memory参数 第一次add不会触发,要fire后才会触发state的变更\r\n\t\t\t\tif (stateString) {\r\n\t\t\t\t\tlist.add(function() {\r\n\t\t\t\t\t\t// state = [ resolved | rejected ]\r\n\t\t\t\t\t\tstate = stateString;\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n                // deferred[ resolve | reject | notify ]\r\n                // 以上方法调用时会触发fireWitch,从而触发队列的进行,即promise的回调\r\n\t\t\t\tdeferred[tuple[0]] = function() {\r\n\t\t\t\t\tdeferred[tuple[0] + \"With\"](this === deferred ? promise : this, arguments);\r\n\t\t\t\t\treturn this;\r\n\t\t\t\t};\r\n\t\t\t\tdeferred[tuple[0] + \"With\"] = list.fireWith;\r\n\t\t\t});\r\n\r\n\t\t\t// Make the deferred a promise\r\n\t\t\tpromise.promise(deferred);\r\n\r\n            console.log(deferred)\r\n\t\t\treturn deferred;\r\n\t\t},\r\n\t\t//执行一个或多个对象的延迟对象的回调函数\r\n\t\twhen: function(subordinate) {\r\n\t\t\treturn subordinate.promise();\r\n\t\t},\r\n    })\r\n    ...\r\n\r\n    jQuery.fn.init.prototype = jQuery.fn \r\n\r\n    root.$ = root.jQuery = jQuery\r\n\r\n})(this);\r\n    `\r\n}];\r\n\r\nexport default { exampleText, javaScriptText };\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/project/jquery-5/text/index.ts"],"sourceRoot":""}