{"version":3,"sources":["project/snake/text/index.ts"],"names":["Object","defineProperty","__webpack_exports__","value","javaScriptText"],"mappings":"qDAGAA,OAAAC,eAAAC,EAAA,cAAAC,OAAA,IAwFeD,EAAA,SAAGE,eAxFK","file":"static/js/23.2dc095d2.chunk.js","sourcesContent":["\r\n\r\n\r\nconst javaScriptText = `\r\nlet ticks$ = interval(SPEED);\r\nlet click$ = fromEvent(document, \"click\");\r\nlet keydown$ = fromEvent(document, \"keydown\");\r\n\r\nfunction createGame(fps$) {\r\n\r\n  // 将键盘输入转换为方向输出\r\n  let direcion$ = keydown$\r\n    .map(event => DIRECTIONS[event.keyCode])\r\n    .filter(direcion => !!direcion)\r\n    .scan(nextDirection)\r\n    .startWith(INITIAL_DIRECTION)\r\n    .distinctUntilChanged() //过滤相同的值\r\n\r\n\r\n  // length作为 BehaviorSubject 既是观察者也可以是被观察到的状态，被传播状态 \r\n  let length$ = new BehaviorSubject(SNAKE_LENGTH);\r\n\r\n  let snakeLength$ = length$\r\n    .scan((step, snakeLength) => snakeLength + step)\r\n    .share()\r\n\r\n  let score$ = snakeLength$\r\n    .startWith(0)\r\n    .scan((score) => score + POINTS_PER_APPLE)\r\n\r\n\r\n  ticks$ = Observable.interval(SPEED);\r\n\r\n\r\n  // 这里有两种实现模式\r\n  // 这种触发更新的机制合并了时间和方向\r\n  // 结果就是时间和按键触发的频率同时会更新蛇的移动\r\n\r\n  // let snake$ = Observable.combineLatest(direcion$, ticks$, (direcion, tick) => direcion)\r\n  //   .withLatestFrom(snakeLength$, (direcion, snakeLength) => [direcion, snakeLength])\r\n  //   .scan(move, generateSnake())\r\n  //   .share()\r\n\r\n\r\n\r\n  // 而这种方式则只把蛇的移动绑定到时间上，每个时间点取按键的最后一次方向\r\n  // 这样能让蛇的移动更加平均，但是会有一个BUG就是当你在时间间隔之中快速操作了↑→↓（假设蛇原来的移动方向是下），这样这个时间点就会检测成发生碰撞结束游戏\r\n\r\n  let snake$ = ticks$\r\n    .withLatestFrom(direcion$, snakeLength$, (tick, direcion, snakeLength) => [direcion, snakeLength])\r\n    .scan(move, generateSnake())\r\n    .share()\r\n\r\n  let apples$ = snake$\r\n    .scan(eat, generateApples())\r\n    .distinctUntilChanged()\r\n    .share();\r\n\r\n  let appleEaten$ = apples$\r\n    .skip(1)\r\n    .do(() => length$.next(POINTS_PER_APPLE))\r\n    .subscribe();\r\n\r\n  let scene$ = Observable.combineLatest(snake$, apples$, score$, (snake, apples, score) => ({ snake, apples, score }));\r\n\r\n  return fps$.pipe(withLatestFrom(scene$, (_, scene) => scene));\r\n}\r\n\r\nlet game$ = of('Start Game').pipe(\r\n  map(() => interval(1000 / FPS, animationFrame)),\r\n  switchMap(createGame),\r\n  takeWhile(scene => !isGameOver(scene))\r\n);\r\n\r\nconst startGame = () => {\r\n  let canvas = createCanvasElement();\r\n  let ctx = canvas.getContext('2d');\r\n  document.getElementById('container').innerHTML = ''\r\n  document.getElementById('container').appendChild(canvas);\r\n\r\n  game$.subscribe({\r\n    next: (scene) => renderScene(ctx, scene),\r\n    complete: () => {\r\n      renderGameOver(ctx);\r\n\r\n      click$.pipe(first()).subscribe(startGame);\r\n    }\r\n  })\r\n};\r\n`;\r\n\r\nexport default {  javaScriptText };\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/project/snake/text/index.ts"],"sourceRoot":""}