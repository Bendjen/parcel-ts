{"version":3,"sources":["project/jquery-4/text/index.ts"],"names":["Object","defineProperty","__webpack_exports__","value","exampleText","javaScriptText","title","text"],"mappings":"qDAAAA,OAAAC,eAAAC,EAAA,cAAAC,OAAA,IAyGeD,EAAA,SAAEE,YAzGG,ivBAyGUC,iBAnF1BC,MAAO,wBACPC,KAAM","file":"static/js/36.95a36242.chunk.js","sourcesContent":["const exampleText = `\r\nvar cb = $.callbacks(\"once unique stopOnFalse memory \");\r\n// once : 队列只会fire一次\r\n// unique : 提出重复的回调\r\n// stopOnFalse : 有其中一个回调返回false就中断后面的回调执行\r\n// memory : fire后,下一次add会记忆上一次的结束位置,直接执行add的回调\r\n\r\ncb.add(function (value) {\r\n    console.log(value)\r\n})\r\nfunction test(value) {\r\n    console.log(value)\r\n}\r\ncb.add(test, test)\r\ncb.fire('hello');        \r\ncb.add(function (value) {   //这里的value会是上次fire的data hello\r\n    console.log(value)\r\n})\r\n\r\n`\r\n\r\nconst javaScriptText = [ {\r\n    title: 'Callbacks源码',\r\n    text: `\r\n(function (root) {\r\n    var jQuery = function (selector, context) {\r\n        // 错误实例化：会造成无限自我调用，形成死循环\r\n        // return  new jQuery();  \r\n        return new jQuery.prototype.init(selector, context)\r\n    }\r\n\r\n    // 为jQuery.prototype起别名jQuery.fn\r\n    jQuery.fn = jQuery.prototype = {\r\n        init: function (selector, context) {\r\n           ...\r\n        },\r\n\r\n    }\r\n\r\n    jQuery.fn.extend = jQuery.extend = function () { ... }\r\n\r\n    jQuery.extend({\r\n        ...\r\n        callbacks: function (options) {\r\n            options = typeof options === \"string\" ? (optionsCache[options] || createOptions(options)) : {};\r\n            var list = [];\r\n            var index, testing, memory, starts, start;\r\n            var fire = function (data) {\r\n                memory = options.memory && data;    // 当fire过一次之后 memory才会变成上次fire的data: [context, arguments]\r\n                index = starts || 0;                // 如果有memory为true，则下次fire从新的任务index开始\r\n                starts = 0;                         // 每次fire后重置starts（包括fire和memory的add）\r\n                testing = true;\r\n                length = list.length;\r\n                for (; index < length; index++) {\r\n                    if (list[index].apply(data[0], data[1]) === false && options.stopOnFalse) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            var self = {\r\n                add: function () {\r\n                    var args = Array.prototype.slice.call(arguments) // 类数组转数组；\r\n                    start = list.length;    // 这里的start要用来记录下一次add前list的长度，memory任务从下一次新增加的第一项开始fire\r\n                    args.forEach(function (fn) {\r\n                        if (toString.call(fn) === '[object Function]') {\r\n                            if (!options.unique || !self.has(fn, list)) {\r\n                                list.push(fn)\r\n                            }\r\n\r\n                        }\r\n                    })\r\n                    if (memory) {               // 如果有memory为true，则下次fire从新的任务index开始\r\n                        starts = start\r\n                        fire(memory)\r\n                    }\r\n\r\n                },\r\n                fireWith: function (context, arguments) {\r\n                    var args = [context, arguments];\r\n                    if (!options.once || !testing) {\r\n                        fire(args)\r\n                    }\r\n\r\n                },\r\n                fire: function () {\r\n                    self.fireWith(this, arguments)  // this指向self\r\n                },\r\n                has: function (fn, list) {\r\n                    var result = list === null ? -1 : [].indexOf.call(list, fn)\r\n                    return result > -1\r\n                },\r\n            }\r\n            return self\r\n        }\r\n    })\r\n    ...\r\n\r\n    jQuery.fn.init.prototype = jQuery.fn \r\n\r\n    root.$ = root.jQuery = jQuery\r\n\r\n})(this);\r\n    `\r\n}];\r\n\r\nexport default { exampleText, javaScriptText };\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/project/jquery-4/text/index.ts"],"sourceRoot":""}