{"version":3,"sources":["project/bidirectionalBindings/text/index.ts"],"names":["Object","defineProperty","__webpack_exports__","value","javaScriptText","title","text"],"mappings":"oDAAAA,OAAAC,eAAAC,EAAA,cAAAC,OAAA,IA6DeD,EAAA,SAAGE,iBAzDdC,MAAM,oCACNC,KAAK,q7EA+BLD,MAAM,iDACNC,KAAK","file":"static/js/39.85272cd2.chunk.js","sourcesContent":["// const htmlText = `<input id=\"inputBox\"/>`;\r\n\r\n\r\nconst javaScriptText = [{\r\n    title:'基于Object.defineProperty',\r\n    text:`//1.该方法是基于对象实现（不能用WeckMap），当dom被删除，对象中绑定的属性不会被释放\r\n//2.理想中的双向绑定应该是    operate => dom => value => doms  或  command => value => doms;\r\n//  但是该方法不是真正的双向绑定实现，其本质是讲原本指向对象属性操作通过get与set转为指向对应的dom的值操作; value(get/set) => dom;\r\n//  导致的结果是当有两个dom绑定同一个值时，value会被指向后绑定的dom，后dom => doms这一步更新需要脏检测才能实现; value(get/set) => dom ≠> doms;\r\n\r\nfunction bind(object, key, domElem, attributeName = \"value\") {\r\n    Object.defineProperty(object, key, {\r\n        //取值从dom中取值\r\n        get: function() {\r\n            return attributeName == \"value\"\r\n                ? domElem.value\r\n                : domElem.getAttribute(attributeName );\r\n        },\r\n        //通过命令设置值时同时设置所有绑定了dom的值\r\n        set: function(value) {\r\n            attributeName == \"value\"\r\n                ? (domElem.value = value)\r\n                : domElem.setAttribute(attributeName, value);\r\n            //问题1：这里少了一步将所有绑定同一个值的dom更新的操作(dom => doms)\r\n        },\r\n        configurable: true\r\n    });\r\n\r\n    //问题2：而且当通过操作dom进行更新时，并没有事件监听可以触发其他相关dom或value更新(dom操作不会触发对象的set)，\r\n    //      value是只有在进行取(get)操作时才能得到dom更新的数据，也就缺少触发更新的事件\r\n}\r\n\r\nlet user = { name: \"\" };\r\nlet inputElem = document.getElementById(\"inputBox\");\r\nbind(user, \"name\", inputElem);`\r\n},{\r\n    title:'基于Object.observe 和 DOM.onChange',\r\n    text:`// value <=>  dom\r\n//这是真正的双向绑定，dom变化时通过事件触发了值的变化，值变化时通过对象监听触发了dom的变化\r\n//但是这种做法的缺陷是当通过代码更改dom的值（不触发dom事件下）不会触发双向绑定\r\n//也没有脏检测可以实现从一个 dom => doms 的一到多扩散\r\n//属于ES7\r\nfunctionbindObjPropToDomElem(obj, property, domElem) { \r\n    Object.observe(obj, function(changes){    \r\n        changes.forEach(function(change) {\r\n         $(domElem).text(obj[property]);        \r\n        });\r\n    });  \r\n}\r\nfunctionbindDomElemToObjProp(obj, propertyName, domElem) {  \r\n    $(domElem).change(function() {\r\n        obj[propertyName] = $(domElem).val();\r\n        console.log(\"obj is\", obj);\r\n    });\r\n}\r\nfunctionbindModelView(obj, property, domElem) {  \r\n    bindObjPropToDomElem(obj, property, domElem)\r\n    bindDomElemToObjProp(obj, propertyName, domElem)\r\n}`\r\n}];\r\n\r\nexport default {  javaScriptText };\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/project/bidirectionalBindings/text/index.ts"],"sourceRoot":""}